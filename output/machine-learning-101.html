<!DOCTYPE HTML>
<html>
    <head>
		<title>Caffeine and Code</title>
        
        <!-- Import bootstrap -->
        <link href="css/bootstrap.min.css" rel="stylesheet">
        <script src="js/bootstrap.bundle.min.js"></script>
        
        <!-- Custom stylesheets -->
        <link href="css/global.css" rel="stylesheet">
        
        <!-- Properties -->
        <meta charset="utf-8">
        <meta name="viewport" content="width=device-width, initial-scale=1">
    </head>
    <body>
        <!-- The navigation bar -->
        <nav class="navbar navbar-expand-sm bg-light navbar-light">
            <div class="container-fluid" id="navbar_logo">
                <a class="navbar-brand" href="/index.html">
		Caffeine and Code
                </a>
            </div>
            <div class="collapse navbar-collapse" id="navbar_main">
                <ul class="navbar-nav me-auto">
                    <!-- Single nav items like this -->
                    <!--<li class="nav-item">
                        <a class="nav-link" href="index.html">Home</a>
                    </li>-->
                    
		<li class="nav-item">		<a class="nav-link" href="index.html">Home</a>		</li>		<li class="nav-item">		<a class="nav-link" href="blog.html">Blog</a>		</li>		<li class="nav-item">		<a class="nav-link" href="contact.html">Contact</a>		</li>		<li class="nav-item">		<a class="nav-link" href="projects.html">Projects</a>		</li>                    
		<li class="nav-item">		<a class="nav-link" href="https://www.linkedin.com/in/patrick-flynn4664/">LinkedIn</a>		</li>		<li class="nav-item">		<a class="nav-link" href="https://github.com/pflynn157/">Github</a>		</li>                    
                    <!--<li class="nav-item">
                        <a class="nav-link" href="https://www.linkedin.com/in/patrick-flynn4664/">LinkedIn</a>
                    </li>
                    
                    <li class="nav-item">
                        <a class="nav-link" href="https://git.sr.ht/~pflynn157/">SourceHut</a>
                    </li>-->
                    
                    <!-- Drop down like this
                    <li class="nav-item dropdown">
                        <a class="nav-link dropdown-toggle" href="#" role="button" data-bs-toggle="dropdown">Source Code</a>
                        <ul class="dropdown-menu">
                            <li><a class="dropdown-item" href="https://hg.sr.ht/~pflynn157/">SourceHut (Mercurial)</a></li>
                            <li><a class="dropdown-item" href="https://git.sr.ht/~pflynn157/">SourceHut (Git)</a></li>
                            <li><a class="dropdown-item" href="https://github.com/pflynn157">Github</a></li>
                        </ul>
                    </li>
                    -->
                </ul>
            </div>
        </nav>
        
<div class="container pt-5">
<h2>Machine Learning 101</h2>
<p><br />

My current summer internship has required me to learn a little bit about AI/Machine Learning. In all honesty, it's something I've been meaning to look at for a while now. The math aspect has led to the procrastination, but now that I'm diving into it, the math doesn't seem as complicated as it initially looks. Today, I'm going to share a simple, introductory machine learning program written in Python.
<br /><br />
To make reading easier, I'm going to divide this into several sections. The complete code can be found near the end. Let's dive in!
<br /><br />
<h2>Neural Networks 101</h2>
<br /><br />
Hopefully I'm not disappointing you, but we aren't about to make something fancy like a speech prediction program :) No, we are simply looking at a simple machine learning program based on a neural network. So what does this mean?
<br /><br />
Computers are great at solving problems. This is where they outshine our human brains. Even the smartest among us have issues making huge calculations quickly- or a huge number of calculations quickly. Computers, on the other hand, can easily do a huge number of calculations quickly and easily. However, computers aren't great at problems like recognition- image recognition, speech recognition, languages, learning, and so forth. These are problems that generally cannot be expressed in terms of simple algorithms.
<br /><br />
Let's take language for an example. Computers are good with programming languages, but only because programming languages follow a tight, absolute syntax. Human languages are anything but that. They are fluid, and syntax and grammar can vary. Not only that, languages are often meant to express abstract concepts, rather than the absolutist concepts of programming languages. There is no algorithm that can be used to accurately represent a human language. The solution? Try to get computers to mimic our brains.
<br /><br />
This is where neural networks come in. Despite their fancy sounding name, they aren't as difficult to understand as they sound. That's the beauty of great ideas by the way- they are often elegant in their simplicity. But anyway. A neural network is made up of a network of interconnected neurons. Each neuron (called a perceptron) has at least two inputs and one output. There is a weight associated with each input, and an overall threshold value. Each weight is multiplied by the input, and all these multiplications are summed. If this sum is greater than the threshold, the perceptron is activated. Otherwise, it stays 0.
<br /><br />
Usually, these weights are not known beforehand. There is where the idea of "training" comes in. When a neural network is trained, it is fed a large amount of data- whatever number of inputs are needed, and the correct answer. The training function feeds a perceptron the inputs. If the output matches the correct answer, great! Otherwise, the weights are adjusted, usually as a combination of the learning rate and the error amount. The learning rate is an important value. We want to adjust the rates, but we don't want to adjust them too much or training does no good.
<br /><br />
<h2>So What Is Our Goal?</h2>
<br /><br />
Hopefully you can see the logical end result of this. By adjusting the rates, we can essentially determine a linear function by no other data than the input. Once the function is sufficiently trained, the perceptron outputs will be very similar to the expected answer. Fun fact: linear algebra is the base of machine learning, so make sure you have a basic familiarity with that.
<br /><br />
In this tutorial, we are going to train a program to solve "y = Ax".
<br /><br />
But there's a catch. We don't know what A is. That's what the computer will have to figure out. X is the input, and Y is the output. Of course, we know beforehand (as the programmer) what A is, so we will calculate some training data. After that, the user should be able to input any X value, and get a very close Y value.
<br /><br />
For this program, A = 1.5.
<br /><br />
<h2>Step 1: The Perceptron</h2>
<br /><br />
Let's start by making the perceptron. The complete code is at the end, but here is part of the perceptron:
<br /><br />
<code>
<br />class&nbsp;Node:<br />&nbsp;&nbsp;&nbsp;&nbsp;A&nbsp;=&nbsp;float(1)<br />&nbsp;&nbsp;&nbsp;&nbsp;L&nbsp;=&nbsp;float(0.1)<br />&nbsp;&nbsp;&nbsp;&nbsp;<br />&nbsp;&nbsp;&nbsp;&nbsp;def&nbsp;calc(self,&nbsp;x):<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;x&nbsp;*&nbsp;self.A<br />&nbsp;&nbsp;&nbsp;&nbsp;<br />&nbsp;&nbsp;&nbsp;&nbsp;def&nbsp;train(self,&nbsp;data):<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;x&nbsp;=&nbsp;data[0]<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;y&nbsp;=&nbsp;data[1]<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;guess&nbsp;=&nbsp;self.A&nbsp;*&nbsp;x<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;error&nbsp;=&nbsp;y&nbsp;-&nbsp;guess<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;error&nbsp;!=&nbsp;0:<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;A2&nbsp;=&nbsp;self.L&nbsp;*&nbsp;(error&nbsp;/&nbsp;x)<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;self.A&nbsp;+=&nbsp;A2<br /></code>
<br /><br />
Let's take a look at this. First of all, in any language, you want your perceptron to be a class or some separate entity of some sort. Python fortunately has classes, so it is very conducive to this. Let us start with the first two class variables: A and L. A is what we are trying to figure out- this would be the "weight" I referred to in the previous section. L is the learning rate. Generally, you want to keep this small. It will take some experimentation to get the optimal value.
<br /><br />
Now let's look at the functions. The "calc" function is pretty straightforward- it returns X based on our current A value. The train function is a little more complicated. It takes a tuple of data: an X value and the expected Y value. The first step is to make a guess- calculate Y based on the current A value. Then we calculate the error: Y - guess (the expected value - guessed value). If there is no error, the error variable will be zero and we have nothing to do. However, if there is an error, we need to adjust A. We calculate an adjustment based on the learning rate and the error, and add it to A.
<br /><br />
And hopefully that made some sort of sense :)
<br /><br />
<h2>Step 2: Train</h2>
<br /><br />
Now, we need to train. In order to train, we have to calculate the data:
<br /><br />
<code>
<br />training&nbsp;=&nbsp;[(0,0)]<br />for&nbsp;i&nbsp;in&nbsp;range(1,&nbsp;10000):<br />&nbsp;&nbsp;&nbsp;&nbsp;y&nbsp;=&nbsp;float(1.5)&nbsp;*&nbsp;float(i)<br />&nbsp;&nbsp;&nbsp;&nbsp;training.append((i,y))<br /></code>
<br /><br />
The training data is an array of tuples: an X value, and the corresponding Y value. As I said above, we know the correct A value is "1.5", so obviously we calculate our training data based on this.
<br /><br />
Something very important to note is the amount of training data. Depending on how much you've read about machine learning, you may have seen stories about the algorithms being trained on <i>huge</i> amounts of data. There is a reason for this. The more you train, the more you can refine your weights, and the more likely you will get the correct results. In this case, we train with 10,000 pieces of data. Huge, right? As you will see shortly, we end up with a very nearly accurate A value. If you adjust the amount of training data, you will find that it becomes less accurate.
<br /><br />
<h2>Putting It All Together</h2>
<br /><br />
You may be surprised- only two steps?!? Yes indeed, a simple machine learning program like this isn't very complicated. The actual algorithm is only 30 lines of Python code, with another 20 for various helper functions. Anyway, here is the complete listing:
<br /><br />
<code>
<br />#!/usr/bin/python3<br /><br />class&nbsp;Node:<br />&nbsp;&nbsp;&nbsp;&nbsp;A&nbsp;=&nbsp;float(1)<br />&nbsp;&nbsp;&nbsp;&nbsp;L&nbsp;=&nbsp;float(0.1)<br />&nbsp;&nbsp;&nbsp;&nbsp;<br />&nbsp;&nbsp;&nbsp;&nbsp;def&nbsp;calc(self,&nbsp;x):<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;x&nbsp;*&nbsp;self.A<br />&nbsp;&nbsp;&nbsp;&nbsp;<br />&nbsp;&nbsp;&nbsp;&nbsp;def&nbsp;train(self,&nbsp;data):<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;x&nbsp;=&nbsp;data[0]<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;y&nbsp;=&nbsp;data[1]<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;guess&nbsp;=&nbsp;self.A&nbsp;*&nbsp;x<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;error&nbsp;=&nbsp;y&nbsp;-&nbsp;guess<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;error&nbsp;!=&nbsp;0:<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;A2&nbsp;=&nbsp;self.L&nbsp;*&nbsp;(error&nbsp;/&nbsp;x)<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;self.A&nbsp;+=&nbsp;A2<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br />&nbsp;&nbsp;&nbsp;&nbsp;def&nbsp;train_all(self,&nbsp;data):<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for&nbsp;d&nbsp;in&nbsp;data:<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;self.train(d)<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br />&nbsp;&nbsp;&nbsp;&nbsp;def&nbsp;print_a(self):<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;print(self.A)<br /><br />#&nbsp;Formula:&nbsp;y&nbsp;=&nbsp;1.5x<br /><br />training&nbsp;=&nbsp;[(0,0)]<br />for&nbsp;i&nbsp;in&nbsp;range(1,&nbsp;10000):<br />&nbsp;&nbsp;&nbsp;&nbsp;y&nbsp;=&nbsp;float(1.5)&nbsp;*&nbsp;float(i)<br />&nbsp;&nbsp;&nbsp;&nbsp;training.append((i,y))<br />&nbsp;&nbsp;&nbsp;&nbsp;<br />#print("")<br />#print("Training&nbsp;data:")<br />#print(training)<br />#print("")<br /><br />node&nbsp;=&nbsp;Node()<br />node.train_all(training)<br /><br />print("A:&nbsp;")<br />node.print_a()<br />print("===================")<br />print("Enter&nbsp;values&nbsp;(0&nbsp;=&nbsp;exit)")<br /><br />enter&nbsp;=&nbsp;float(input("&gt;&nbsp;"))<br />while&nbsp;enter&nbsp;!=&nbsp;0:<br />&nbsp;&nbsp;&nbsp;&nbsp;expected&nbsp;=&nbsp;float(enter*1.5)<br />&nbsp;&nbsp;&nbsp;&nbsp;guess&nbsp;=&nbsp;node.calc(enter)<br />&nbsp;&nbsp;&nbsp;&nbsp;print("Guess:&nbsp;"&nbsp;+&nbsp;str(guess)&nbsp;+&nbsp;"&nbsp;|&nbsp;Expected:&nbsp;"&nbsp;+&nbsp;str(expected))<br />&nbsp;&nbsp;&nbsp;&nbsp;print("")<br />&nbsp;&nbsp;&nbsp;&nbsp;enter&nbsp;=&nbsp;float(input("&gt;&nbsp;"))<br /></code>
<br /><br />
And here is what the output looks like:
<br /><br />
<img class="img-fluid" src="assets/images/ml1.png"></img>
<br /><br />
Take a look at the A value here. Remember that the correct A value was 1.5? As you can see, the machine learning algorithm was very, very close- close enough to be accurate for our purposes. If you look at the calculations, you can see that they too are also quite close.
<br /><br />
<h2>Training Size and Learning Rate</h2>
<br /><br />
Remember how I said that both the training size and the learning rate are important to getting the correct results? Using the code above, let's experiment with that sum!
<br /><br />
First, let's change the training size to "10" and "100" respectively:
<br /><br />
<img class="img-fluid" src="assets/images/training10.png"></img>
<br /><br />
Training with 10 values
<br /><br />
<img class="img-fluid" src="assets/images/training100.png"></img>
<br /><br />
Training with 100 values
<br /><br />
As you can see, training with 10 values isn't great. The results are in the ballpark, but that's really it. As you get to larger and larger values, they will become more and more wrong. Now take a look at what happens with 100 training values. It's better- it's not horrible- but it's still not great. It ultimately takes experimentation to determine how many training values you need, but as a rule of thumb: more is better.
<br /><br />
Now let's take a look at the learning rate. We're going to change it to 1 (no learning rate), 1.2, 0.5, and 0.01:
<br /><br />
<img class="img-fluid" src="assets/images/lr1.png"></img>
<br /><br />
Learning rate of 1
<br /><br />
<img class="img-fluid" src="assets/images/lr1.5.png"></img>
<br /><br />
Learning rate of 1.5
<br /><br />
<img class="img-fluid" src="assets/images/lr0.5.png"></img>
<br /><br />
Learning rate of 0.5
<br /><br />
<img class="img-fluid" src="assets/images/lr0.01.png"></img>
<br /><br />
Learning rate of 0.01
<br /><br />
See the benefits of experimenting with different learning rates? As you can see, when we changed it, we ultimately ended up with an even better, or even completely correct result than we started. Of course, you have to realize this was a simple problem. As you get into more advanced problems, having an absolute learning rate will not be beneficial.
<br /><br />
<h2>Conclusion</h2>
<br /><br />
Hopefully you found this little introduction to machine learning interesting! I certainly did- when I first dove into it, I was amazed at what a good idea the neural, perceptron model was. It's really amazing what we can get computers to do.
<br /><br />
This warrants an entirely separate post, but AI/machine learning is dangerous territory. Let me be clear: I'm not against AI/ML as a concept. There are areas where it can be incredibly useful. But we must tread lightly as a society. The technology will only continue to advance, and like any tool, it AI can be leveraged for good, useful purposes, but it can also be leveraged for evil, controlling purposes. As a society, we've been viewing technology through a lens that any achievement- any advancement- is by definition good. Fortunately, there is a change- a waking up to this- but not enough people have woken up to it. Perhaps in no other area of computer science as AI do we need to take a serious look at the ethics and make sure we do our part to stay on the right side of history with this technology.
<br /><br />
Like I said, I originally began exploring AI/ML because of my job- there is potential to apply machine learning in various development environments- but I also began learning because I wanted to understand the technology better. I intend to keep learning.
<br /><br />
But anyway. Enough statements. I hope you found this interesting and informative!
<br /><br />
<br /><br />
<br /><br /><br /></p>
</div>
    </body>
</html>

