<!DOCTYPE HTML>
<html>
    <head>
		<title>Caffeine and Code</title>
        
        <!-- Import bootstrap -->
        <link href="css/bootstrap.min.css" rel="stylesheet">
        <script src="js/bootstrap.bundle.min.js"></script>
        
        <!-- Custom stylesheets -->
        <link href="css/global.css" rel="stylesheet">
        
        <!-- Properties -->
        <meta charset="utf-8">
        <meta name="viewport" content="width=device-width, initial-scale=1">
    </head>
    <body>
        <!-- The navigation bar -->
        <nav class="navbar navbar-expand-sm bg-light navbar-light">
            <div class="container-fluid" id="navbar_logo">
                <a class="navbar-brand" href="/index.html">
		Caffeine and Code
                </a>
            </div>
            <div class="collapse navbar-collapse" id="navbar_main">
                <ul class="navbar-nav me-auto">
                    <!-- Single nav items like this -->
                    <!--<li class="nav-item">
                        <a class="nav-link" href="index.html">Home</a>
                    </li>-->
                    
		<li class="nav-item">		<a class="nav-link" href="index.html">Home</a>		</li>		<li class="nav-item">		<a class="nav-link" href="blog.html">Blog</a>		</li>		<li class="nav-item">		<a class="nav-link" href="contact.html">Contact</a>		</li>		<li class="nav-item">		<a class="nav-link" href="projects.html">Projects</a>		</li>                    
		<li class="nav-item">		<a class="nav-link" href="https://www.linkedin.com/in/patrick-flynn4664/">LinkedIn</a>		</li>		<li class="nav-item">		<a class="nav-link" href="https://git.sr.ht/~pflynn157/">SourceHut</a>		</li>                    
                    <!--<li class="nav-item">
                        <a class="nav-link" href="https://www.linkedin.com/in/patrick-flynn4664/">LinkedIn</a>
                    </li>
                    
                    <li class="nav-item">
                        <a class="nav-link" href="https://git.sr.ht/~pflynn157/">SourceHut</a>
                    </li>-->
                    
                    <!-- Drop down like this
                    <li class="nav-item dropdown">
                        <a class="nav-link dropdown-toggle" href="#" role="button" data-bs-toggle="dropdown">Source Code</a>
                        <ul class="dropdown-menu">
                            <li><a class="dropdown-item" href="https://hg.sr.ht/~pflynn157/">SourceHut (Mercurial)</a></li>
                            <li><a class="dropdown-item" href="https://git.sr.ht/~pflynn157/">SourceHut (Git)</a></li>
                            <li><a class="dropdown-item" href="https://github.com/pflynn157">Github</a></li>
                        </ul>
                    </li>
                    -->
                </ul>
            </div>
        </nav>
        
<div class="container pt-5">
<h2>Building a Lexer</h2>
<p><br />

Welcome back!
<br /><br />
As promised in the last post, this post will contain an actual hands-on example in creating a lexical analyzer. You can find the complete program at the end of this post. Through the post, I will break it down into digestible parts so you can understand how it works and hopefully better understand the greater concept behind this.
<br /><br />
<h3>Token Structure</h3>
<br /><br />
While there are probably different ways to do this, my preferred method is to use a structure and an enumeration to represent tokens. Here are the structures:
<br /><br />
<code>
<br />enum&nbsp;TokenType&nbsp;{<br />&nbsp;&nbsp;&nbsp;&nbsp;None,<br />&nbsp;&nbsp;&nbsp;&nbsp;Eof,<br />&nbsp;&nbsp;&nbsp;&nbsp;<br />&nbsp;&nbsp;&nbsp;&nbsp;Int,<br />&nbsp;&nbsp;&nbsp;&nbsp;<br />&nbsp;&nbsp;&nbsp;&nbsp;Assign,<br />&nbsp;&nbsp;&nbsp;&nbsp;SemiColon,<br />&nbsp;&nbsp;&nbsp;&nbsp;<br />&nbsp;&nbsp;&nbsp;&nbsp;Id,<br />&nbsp;&nbsp;&nbsp;&nbsp;IntL<br />};<br /><br />//&nbsp;The&nbsp;token&nbsp;structure.&nbsp;This&nbsp;holds&nbsp;all&nbsp;the&nbsp;information&nbsp;about&nbsp;the&nbsp;token.<br />struct&nbsp;Token&nbsp;{<br />&nbsp;&nbsp;&nbsp;&nbsp;TokenType&nbsp;type;<br />&nbsp;&nbsp;&nbsp;&nbsp;std::string&nbsp;idVal;<br />&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;intVal;<br />};<br /></code>
<br /><br />
The structure is what actually gets returned. The `TokenType` enumeration represents the token itself. The enumeration is important. Enumerations are basically named integer values, which is ideal for comparisons. This is what the parser uses to determine what type of token its looking at, and where to go from there.
<br /><br />
As you may remember, some tokens represent identifiers and literals, so the parser will not only need to know what type of token it has, but also what the content of the token is. That's where the structure comes in. If the token is an identifier, the "idVal" struct member will be set. If the token is an integer literal, the "intVal" member will be set. And so on.
<br /><br />
I've read that some lexers use functions to store the current buffer or something like that, but I find that this solution works the best. I've never measured performance, but realistically, I can't see it being worse than other methods as long as you don't start heap-allocating things.
<br /><br />
<h3>Why a Class?</h3>
<br /><br />
Okay, let's talk about the structure. You may have noticed that I wrapped everything into a class:
<br /><br />
<code>
<br />class&nbsp;Scanner&nbsp;{<br />public:<br />&nbsp;&nbsp;&nbsp;&nbsp;explicit&nbsp;Scanner(std::string&nbsp;input)&nbsp;{<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this-&gt;input&nbsp;=&nbsp;input;<br />&nbsp;&nbsp;&nbsp;&nbsp;}<br />&nbsp;&nbsp;&nbsp;&nbsp;<br />&nbsp;&nbsp;&nbsp;&nbsp;bool&nbsp;isSymbol(char&nbsp;c);<br />&nbsp;&nbsp;&nbsp;&nbsp;bool&nbsp;isInteger();<br />&nbsp;&nbsp;&nbsp;&nbsp;TokenType&nbsp;getSymbol(char&nbsp;c);<br />&nbsp;&nbsp;&nbsp;&nbsp;TokenType&nbsp;getKeyword();<br />&nbsp;&nbsp;&nbsp;&nbsp;<br />&nbsp;&nbsp;&nbsp;&nbsp;Token&nbsp;getNext();<br /><br />&nbsp;&nbsp;&nbsp;&nbsp;bool&nbsp;isEof();<br />&nbsp;&nbsp;&nbsp;&nbsp;char&nbsp;getChar();<br />private:<br />&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;Control&nbsp;variables&nbsp;needed&nbsp;by&nbsp;our&nbsp;class<br />&nbsp;&nbsp;&nbsp;&nbsp;std::stack&lt;Token&gt;&nbsp;tokenStack;<br />&nbsp;&nbsp;&nbsp;&nbsp;std::string&nbsp;buffer&nbsp;=&nbsp;"";<br />&nbsp;&nbsp;&nbsp;&nbsp;<br />&nbsp;&nbsp;&nbsp;&nbsp;std::string&nbsp;input;<br />&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;pos&nbsp;=&nbsp;0;<br />};<br /></code>
<br /><br />
While object-oriented programming isn't my favorite thing ever, this is one area where I think it shines. In general, I think OOP is a well-suited to compilers since it can represent various inter-relationships among components. But that's another topic for another day...
<br /><br />
Anyway. I highly recommend that you wrap your scanner and all its component functions into a structure of some sort. Classes in C++, Java, and C# are best. In Rust, I used a structure, which worked really, really well. Doing so will allow easy access amongst your functions to the buffer, the file reader, the token stack, and so forth. Moreover, it makes for a cleaner design since you are not having to pass stuff all over the place.
<br /><br />
<h3>Scanning</h3>
<br /><br />
Ok, let's talk about this function:
<br /><br />
<code>
<br />Token&nbsp;Scanner::getNext()<br /></code>
<br /><br />
This was something that actually threw me off back in my early compiler days. I thought parsers wanted a list of tokens returned, not one at a time. But in fact, this method works the best. When you read one token at a time, that sets things up for what to read next- what path to take in the parser (ie, do we have a variable declaration, function call, or something else?). If this doesn't make sense to you right off, don't worry; its not essential for understanding this post.
<br /><br />
The "getNext()" routine starts with these two if-statements:
<br /><br />
<code>
<br />&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(tokenStack.size()&nbsp;&gt;&nbsp;0)&nbsp;{<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Token&nbsp;token&nbsp;=&nbsp;tokenStack.top();<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;tokenStack.pop();<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;token;<br />&nbsp;&nbsp;&nbsp;&nbsp;}<br /><br />&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(isEof())&nbsp;{<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Token&nbsp;token;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;token.type&nbsp;=&nbsp;Eof;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;token;<br />&nbsp;&nbsp;&nbsp;&nbsp;}<br /></code>
<br /><br />
When the function is called, the very first thing we need to do is check the token stack. Even if we're at the end of the file, we should return tokens until the stack is completely empty. The next if-statement checks to see if we're at the end of the file. If we are, we return a token for that.
<br /><br />
Next, we arrive at our loop:
<br /><br />
<code>
<br />&nbsp;&nbsp;&nbsp;&nbsp;while&nbsp;(!isEof())&nbsp;{<br />&nbsp;&nbsp;&nbsp;&nbsp;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;Get&nbsp;the&nbsp;next&nbsp;character&nbsp;in&nbsp;the&nbsp;input&nbsp;stream<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;char&nbsp;next&nbsp;=&nbsp;getChar();<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;If&nbsp;we&nbsp;find&nbsp;a&nbsp;separator&nbsp;or&nbsp;a&nbsp;symbol,&nbsp;its&nbsp;time&nbsp;to&nbsp;do&nbsp;work!<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(next&nbsp;==&nbsp;'&nbsp;'&nbsp;||&nbsp;isSymbol(next))&nbsp;{<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;DO&nbsp;WORK....<br /><br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;Otherwise,&nbsp;just&nbsp;add&nbsp;the&nbsp;current&nbsp;character&nbsp;to&nbsp;the&nbsp;buffer<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;else&nbsp;{<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;buffer&nbsp;+=&nbsp;next;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br />&nbsp;&nbsp;&nbsp;&nbsp;}<br /></code>
<br /><br />
Ideally, the base case of the loop should never be reached, but it's there as a safeguard to prevent infinite loops. Inside the loop, the first thing we do is get the next character. If the next character is a separator (a space) or a symbol (ie, '=' or ';'), then we need to stop and analyze. Otherwise, the character is part of a larger token, so we add it to the buffer.
<br /><br />
Once inside the loop, we need to do a variety of checks. This code probably could be cleaner, but for explanation its better as is:
<br /><br />
<code>
<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;See&nbsp;if&nbsp;we&nbsp;have&nbsp;a&nbsp;symbol.&nbsp;If&nbsp;so,&nbsp;we&nbsp;need&nbsp;to&nbsp;create&nbsp;a&nbsp;token<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(isSymbol(next))&nbsp;{<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Token&nbsp;token;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;token.type&nbsp;=&nbsp;getSymbol(next);<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;If&nbsp;the&nbsp;buffer&nbsp;is&nbsp;empty,&nbsp;we&nbsp;can&nbsp;return&nbsp;the&nbsp;token&nbsp;immediately.&nbsp;Otherwise,<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;it&nbsp;needs&nbsp;to&nbsp;go&nbsp;on&nbsp;the&nbsp;stack.<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(buffer.length()&nbsp;==&nbsp;0)&nbsp;{<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;token;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;else&nbsp;{<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;tokenStack.push(token);<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;If&nbsp;the&nbsp;buffer&nbsp;is&nbsp;empty,&nbsp;don't&nbsp;do&nbsp;anything-&nbsp;just&nbsp;continue.<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(buffer.length()&nbsp;==&nbsp;0)&nbsp;{<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;continue;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br /></code>
<br /><br />
All this code handles scenarios where a symbol representing a valid token follows another token, such as a keyword or an identifier. The first if-statement verifies that the symbol is a valid token, and if so, it will build that token. Now, if the buffer is empty (ie, a token following a token or a separator), we can return the token immediately. Otherwise, it needs to go on the stack so we can process the buffer. The next if-statement just checks to see if the buffer is empty (ie, two spaces were found). If the buffer is empty, we just continue on with the loop.
<br /><br />
Once we have completed the symbol check and verified that something is in the buffer, we can check the buffer itself:
<br /><br />
<code>
<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;Check&nbsp;the&nbsp;buffer&nbsp;to&nbsp;see&nbsp;whether&nbsp;we&nbsp;have&nbsp;a&nbsp;keyword,&nbsp;literal,&nbsp;or&nbsp;identifier<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;An&nbsp;identifier&nbsp;is&nbsp;the&nbsp;default&nbsp;case<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Token&nbsp;token;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(getKeyword()&nbsp;!=&nbsp;None)&nbsp;{<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;token.type&nbsp;=&nbsp;getKeyword();<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;else&nbsp;if&nbsp;(isInteger())&nbsp;{<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;token.type&nbsp;=&nbsp;IntL;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;token.intVal&nbsp;=&nbsp;std::stoi(buffer);<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;else&nbsp;{<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;token.type&nbsp;=&nbsp;Id;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;token.idVal&nbsp;=&nbsp;buffer;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;buffer&nbsp;=&nbsp;"";<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;token;<br /></code>
<br /><br />
This check is pretty straightforward. First, we need to see if we have a keyword. This should come first, as keywords have precedence over other tokens. Next, we check on literals. In this case, we are only checking for numerical literals, but in real life, you would need to check for things like floating point and hexadecimal literals. Finally, if all else fails, we have an identifier. If your language has rules of what does and does not constitute a valid identifier, this would be a good place to check. Bear in mind though that if you do, you will need error handling on this level.
<br /><br />
See the full code listing for how these check functions are carried out. At the end, we clear the buffer and return the token.
<br /><br />
<h3>The Driver</h3>
<br /><br />
Now for testing. Ideally this would be part of a parser, but we just want to see if it works. Here's the code:
<br /><br />
<code>
<br />//&nbsp;The&nbsp;driver&nbsp;function&nbsp;for&nbsp;testing&nbsp;our&nbsp;lexical&nbsp;analyzer<br />int&nbsp;main()&nbsp;{<br />&nbsp;&nbsp;&nbsp;&nbsp;std::cout&nbsp;&lt;&lt;&nbsp;"Enter&nbsp;a&nbsp;line&nbsp;to&nbsp;analyze:"&nbsp;&lt;&lt;&nbsp;std::endl;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br />&nbsp;&nbsp;&nbsp;&nbsp;std::string&nbsp;line&nbsp;=&nbsp;"";<br />&nbsp;&nbsp;&nbsp;&nbsp;std::getline(std::cin,&nbsp;line);<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br />&nbsp;&nbsp;&nbsp;&nbsp;Scanner&nbsp;scanner(line);<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br />&nbsp;&nbsp;&nbsp;&nbsp;Token&nbsp;token&nbsp;=&nbsp;scanner.getNext();<br />&nbsp;&nbsp;&nbsp;&nbsp;while&nbsp;(token.type&nbsp;!=&nbsp;Eof)&nbsp;{<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;switch&nbsp;(token.type)&nbsp;{<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;case&nbsp;Short:&nbsp;std::cout&nbsp;&lt;&lt;&nbsp;"Keyword:&nbsp;short"&nbsp;&lt;&lt;&nbsp;std::endl;&nbsp;break;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;case&nbsp;Int:&nbsp;std::cout&nbsp;&lt;&lt;&nbsp;"Keyword:&nbsp;int"&nbsp;&lt;&lt;&nbsp;std::endl;&nbsp;break;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;case&nbsp;Assign:&nbsp;std::cout&nbsp;&lt;&lt;&nbsp;"Symbol:&nbsp;\'=\'"&nbsp;&lt;&lt;&nbsp;std::endl;&nbsp;break;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;case&nbsp;SemiColon:&nbsp;std::cout&nbsp;&lt;&lt;&nbsp;"Symbol:&nbsp;\';\'"&nbsp;&lt;&lt;&nbsp;std::endl;&nbsp;break;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;case&nbsp;Id:&nbsp;std::cout&nbsp;&lt;&lt;&nbsp;"Identifier:&nbsp;"&nbsp;&lt;&lt;&nbsp;token.idVal&nbsp;&lt;&lt;&nbsp;std::endl;&nbsp;break;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;case&nbsp;IntL:&nbsp;std::cout&nbsp;&lt;&lt;&nbsp;"Integer&nbsp;Literal:&nbsp;"&nbsp;&lt;&lt;&nbsp;token.intVal&nbsp;&lt;&lt;&nbsp;std::endl;&nbsp;break;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;default:&nbsp;{<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;std::cout&nbsp;&lt;&lt;&nbsp;"Error:&nbsp;Unknown&nbsp;token."&nbsp;&lt;&lt;&nbsp;std::endl;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;token&nbsp;=&nbsp;scanner.getNext();<br />&nbsp;&nbsp;&nbsp;&nbsp;}<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br />&nbsp;&nbsp;&nbsp;&nbsp;std::cout&nbsp;&lt;&lt;&nbsp;"EOF&nbsp;reached."&nbsp;&lt;&lt;&nbsp;std::endl;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br />&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;0;<br />}<br /></code>
<br /><br />
As you can see, its pretty straightforward. We simply get an input string from the console, feed it to the lexer, and get each token out one by one. The loop runs until it's out of tokens to read. Experiment with it- see what works and what doesn't. As a bonus, try adding some of your own symbols or keywords, and see what happens.
<br /><br />
To compile, any C++ compiler will work. No special libraries or flags are needed.
<br /><br />
<h3>Full Listing</h3>
<br /><br />
Below is the full code listing. This code is in the public domain.
<br /><br />
<code>
<br />//&nbsp;Goal:&nbsp;Parse&nbsp;this:&nbsp;int&nbsp;x&nbsp;=&nbsp;20;<br />&nbsp;<br />#include&nbsp;&lt;iostream&gt;<br />#include&nbsp;&lt;string&gt;<br />#include&nbsp;&lt;stack&gt;<br />#include&nbsp;&lt;cctype&gt;<br />&nbsp;<br />//&nbsp;An&nbsp;enumeration&nbsp;representing&nbsp;the&nbsp;types&nbsp;of&nbsp;tokens&nbsp;we&nbsp;could&nbsp;have<br />//&nbsp;We&nbsp;use&nbsp;an&nbsp;enum&nbsp;because&nbsp;its&nbsp;easy&nbsp;to&nbsp;understand,&nbsp;and&nbsp;allows&nbsp;for&nbsp;quick<br />//&nbsp;comparisons&nbsp;in&nbsp;the&nbsp;parser.<br />enum&nbsp;TokenType&nbsp;{<br />&nbsp;&nbsp;&nbsp;&nbsp;None,<br />&nbsp;&nbsp;&nbsp;&nbsp;Eof,<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br />&nbsp;&nbsp;&nbsp;&nbsp;Short,<br />&nbsp;&nbsp;&nbsp;&nbsp;Int,<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br />&nbsp;&nbsp;&nbsp;&nbsp;Assign,<br />&nbsp;&nbsp;&nbsp;&nbsp;SemiColon,<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br />&nbsp;&nbsp;&nbsp;&nbsp;Id,<br />&nbsp;&nbsp;&nbsp;&nbsp;IntL<br />};<br />&nbsp;<br />//&nbsp;The&nbsp;token&nbsp;structure.&nbsp;This&nbsp;holds&nbsp;all&nbsp;the&nbsp;information&nbsp;about&nbsp;the&nbsp;token.<br />struct&nbsp;Token&nbsp;{<br />&nbsp;&nbsp;&nbsp;&nbsp;TokenType&nbsp;type;<br />&nbsp;&nbsp;&nbsp;&nbsp;std::string&nbsp;idVal;<br />&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;intVal;<br />};<br />&nbsp;<br />//&nbsp;Its&nbsp;best&nbsp;to&nbsp;wrap&nbsp;the&nbsp;scanner&nbsp;into&nbsp;a&nbsp;pass.&nbsp;In&nbsp;real&nbsp;life,&nbsp;this&nbsp;should<br />//&nbsp;be&nbsp;separated&nbsp;into&nbsp;a&nbsp;header&nbsp;and&nbsp;source&nbsp;file,&nbsp;but&nbsp;since&nbsp;this&nbsp;is&nbsp;an<br />//&nbsp;example,&nbsp;its&nbsp;sufficient&nbsp;to&nbsp;do&nbsp;it&nbsp;like&nbsp;this.<br />class&nbsp;Scanner&nbsp;{<br />public:<br />&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;In&nbsp;real&nbsp;life,&nbsp;the&nbsp;scanner&nbsp;would&nbsp;read&nbsp;directly&nbsp;from&nbsp;the&nbsp;file.&nbsp;Again,&nbsp;since&nbsp;this<br />&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;is&nbsp;an&nbsp;example,&nbsp;things&nbsp;are&nbsp;different.&nbsp;The&nbsp;first&nbsp;three&nbsp;functions&nbsp;are&nbsp;used&nbsp;to&nbsp;simulate<br />&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;common&nbsp;file&nbsp;functions&nbsp;that&nbsp;the&nbsp;lexer&nbsp;would&nbsp;use.<br />&nbsp;&nbsp;&nbsp;&nbsp;explicit&nbsp;Scanner(std::string&nbsp;input)&nbsp;{<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this-&gt;input&nbsp;=&nbsp;input;<br />&nbsp;&nbsp;&nbsp;&nbsp;}<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br />&nbsp;&nbsp;&nbsp;&nbsp;bool&nbsp;isEof()&nbsp;{<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(pos&nbsp;&gt;=&nbsp;input.length())&nbsp;return&nbsp;true;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;false;<br />&nbsp;&nbsp;&nbsp;&nbsp;}<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br />&nbsp;&nbsp;&nbsp;&nbsp;char&nbsp;getChar()&nbsp;{<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(isEof())&nbsp;return&nbsp;0;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;char&nbsp;c&nbsp;=&nbsp;input[pos];<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;++pos;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;c;<br />&nbsp;&nbsp;&nbsp;&nbsp;}<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br />&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;Checks&nbsp;to&nbsp;see&nbsp;whether&nbsp;the&nbsp;given&nbsp;character&nbsp;is&nbsp;a&nbsp;symbol&nbsp;or&nbsp;not<br />&nbsp;&nbsp;&nbsp;&nbsp;bool&nbsp;isSymbol(char&nbsp;c)&nbsp;{<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;switch&nbsp;(c)&nbsp;{<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;case&nbsp;'=':<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;case&nbsp;';':&nbsp;return&nbsp;true;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;default:&nbsp;return&nbsp;false;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br />&nbsp;&nbsp;&nbsp;&nbsp;}<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br />&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;Checks&nbsp;to&nbsp;see&nbsp;if&nbsp;a&nbsp;given&nbsp;string&nbsp;is&nbsp;an&nbsp;integer&nbsp;literal<br />&nbsp;&nbsp;&nbsp;&nbsp;bool&nbsp;isInteger()&nbsp;{<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for&nbsp;(char&nbsp;c&nbsp;:&nbsp;buffer)&nbsp;{<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(!isdigit(c))&nbsp;return&nbsp;false;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;true;<br />&nbsp;&nbsp;&nbsp;&nbsp;}<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br />&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;Returns&nbsp;the&nbsp;corresponding&nbsp;token&nbsp;type&nbsp;for&nbsp;a&nbsp;given&nbsp;character<br />&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;Because&nbsp;of&nbsp;the&nbsp;isSymbol()&nbsp;function,&nbsp;we&nbsp;should&nbsp;never&nbsp;get&nbsp;to&nbsp;the<br />&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;default&nbsp;case.<br />&nbsp;&nbsp;&nbsp;&nbsp;TokenType&nbsp;getSymbol(char&nbsp;c)&nbsp;{<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;switch&nbsp;(c)&nbsp;{<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;case&nbsp;'=':&nbsp;return&nbsp;Assign;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;case&nbsp;';':&nbsp;return&nbsp;SemiColon;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;default:&nbsp;return&nbsp;None;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br />&nbsp;&nbsp;&nbsp;&nbsp;}<br />&nbsp;&nbsp;&nbsp;&nbsp;<br />&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;Returns&nbsp;a&nbsp;keyword&nbsp;for&nbsp;the&nbsp;buffer,&nbsp;or&nbsp;empty&nbsp;otherwise<br />&nbsp;&nbsp;&nbsp;&nbsp;TokenType&nbsp;getKeyword()&nbsp;{<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(buffer&nbsp;==&nbsp;"short")&nbsp;return&nbsp;Short;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;else&nbsp;if&nbsp;(buffer&nbsp;==&nbsp;"int")&nbsp;return&nbsp;Int;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;None;<br />&nbsp;&nbsp;&nbsp;&nbsp;}<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br />&nbsp;&nbsp;&nbsp;&nbsp;Token&nbsp;getNext();<br />private:<br />&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;Control&nbsp;variables&nbsp;needed&nbsp;by&nbsp;our&nbsp;class<br />&nbsp;&nbsp;&nbsp;&nbsp;std::stack&lt;Token&gt;&nbsp;tokenStack;<br />&nbsp;&nbsp;&nbsp;&nbsp;std::string&nbsp;buffer&nbsp;=&nbsp;"";<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br />&nbsp;&nbsp;&nbsp;&nbsp;std::string&nbsp;input;<br />&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;pos&nbsp;=&nbsp;0;<br />};<br />&nbsp;<br />//&nbsp;The&nbsp;main&nbsp;lexical&nbsp;routine<br />Token&nbsp;Scanner::getNext()&nbsp;{<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br />&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;First,&nbsp;check&nbsp;the&nbsp;stack.&nbsp;If&nbsp;there&nbsp;are&nbsp;tokens&nbsp;on&nbsp;it,&nbsp;pop&nbsp;one&nbsp;and&nbsp;return<br />&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(tokenStack.size()&nbsp;&gt;&nbsp;0)&nbsp;{<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Token&nbsp;token&nbsp;=&nbsp;tokenStack.top();<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;tokenStack.pop();<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;token;<br />&nbsp;&nbsp;&nbsp;&nbsp;}<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br />&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;Make&nbsp;sure&nbsp;we're&nbsp;not&nbsp;at&nbsp;the&nbsp;end&nbsp;of&nbsp;the&nbsp;file<br />&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;If&nbsp;we&nbsp;are,&nbsp;send&nbsp;an&nbsp;end-of-file&nbsp;token.<br />&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(isEof())&nbsp;{<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Token&nbsp;token;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;token.type&nbsp;=&nbsp;Eof;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;token;<br />&nbsp;&nbsp;&nbsp;&nbsp;}<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br />&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;Continue&nbsp;looping&nbsp;until&nbsp;we&nbsp;either&nbsp;find&nbsp;a&nbsp;token&nbsp;or&nbsp;hit&nbsp;the&nbsp;end&nbsp;of&nbsp;the&nbsp;file.<br />&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;If&nbsp;we&nbsp;hit&nbsp;the&nbsp;end&nbsp;of&nbsp;the&nbsp;file,&nbsp;something&nbsp;is&nbsp;probably&nbsp;wrong.<br />&nbsp;&nbsp;&nbsp;&nbsp;while&nbsp;(!isEof())&nbsp;{<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;Get&nbsp;the&nbsp;next&nbsp;character&nbsp;in&nbsp;the&nbsp;input&nbsp;stream<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;char&nbsp;next&nbsp;=&nbsp;getChar();<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;If&nbsp;we&nbsp;find&nbsp;a&nbsp;separator&nbsp;or&nbsp;a&nbsp;symbol,&nbsp;its&nbsp;time&nbsp;to&nbsp;do&nbsp;work!<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(next&nbsp;==&nbsp;'&nbsp;'&nbsp;||&nbsp;isSymbol(next))&nbsp;{<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;See&nbsp;if&nbsp;we&nbsp;have&nbsp;a&nbsp;symbol.&nbsp;If&nbsp;so,&nbsp;we&nbsp;need&nbsp;to&nbsp;create&nbsp;a&nbsp;token<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(isSymbol(next))&nbsp;{<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Token&nbsp;token;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;token.type&nbsp;=&nbsp;getSymbol(next);<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;If&nbsp;the&nbsp;buffer&nbsp;is&nbsp;empty,&nbsp;we&nbsp;can&nbsp;return&nbsp;the&nbsp;token&nbsp;immediately.&nbsp;Otherwise,<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;it&nbsp;needs&nbsp;to&nbsp;go&nbsp;on&nbsp;the&nbsp;stack.<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(buffer.length()&nbsp;==&nbsp;0)&nbsp;{<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;token;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;else&nbsp;{<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;tokenStack.push(token);<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;If&nbsp;the&nbsp;buffer&nbsp;is&nbsp;empty,&nbsp;don't&nbsp;do&nbsp;anything-&nbsp;just&nbsp;continue.<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(buffer.length()&nbsp;==&nbsp;0)&nbsp;{<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;continue;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;Check&nbsp;the&nbsp;buffer&nbsp;to&nbsp;see&nbsp;whether&nbsp;we&nbsp;have&nbsp;a&nbsp;keyword,&nbsp;literal,&nbsp;or&nbsp;identifier<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;An&nbsp;identifier&nbsp;is&nbsp;the&nbsp;default&nbsp;case<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Token&nbsp;token;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(getKeyword()&nbsp;!=&nbsp;None)&nbsp;{<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;token.type&nbsp;=&nbsp;getKeyword();<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;else&nbsp;if&nbsp;(isInteger())&nbsp;{<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;token.type&nbsp;=&nbsp;IntL;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;token.intVal&nbsp;=&nbsp;std::stoi(buffer);<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;else&nbsp;{<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;token.type&nbsp;=&nbsp;Id;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;token.idVal&nbsp;=&nbsp;buffer;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;buffer&nbsp;=&nbsp;"";<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;token;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;Otherwise,&nbsp;just&nbsp;add&nbsp;the&nbsp;current&nbsp;character&nbsp;to&nbsp;the&nbsp;buffer<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;else&nbsp;{<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;buffer&nbsp;+=&nbsp;next;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br />&nbsp;&nbsp;&nbsp;&nbsp;}<br />&nbsp;&nbsp;&nbsp;&nbsp;<br />&nbsp;&nbsp;&nbsp;&nbsp;Token&nbsp;token;<br />&nbsp;&nbsp;&nbsp;&nbsp;token.type&nbsp;=&nbsp;None;<br />&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;token;<br />}<br />&nbsp;<br />//&nbsp;The&nbsp;driver&nbsp;function&nbsp;for&nbsp;testing&nbsp;our&nbsp;lexical&nbsp;analyzer<br />int&nbsp;main()&nbsp;{<br />&nbsp;&nbsp;&nbsp;&nbsp;std::cout&nbsp;&lt;&lt;&nbsp;"Enter&nbsp;a&nbsp;line&nbsp;to&nbsp;analyze:"&nbsp;&lt;&lt;&nbsp;std::endl;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br />&nbsp;&nbsp;&nbsp;&nbsp;std::string&nbsp;line&nbsp;=&nbsp;"";<br />&nbsp;&nbsp;&nbsp;&nbsp;std::getline(std::cin,&nbsp;line);<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br />&nbsp;&nbsp;&nbsp;&nbsp;Scanner&nbsp;scanner(line);<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br />&nbsp;&nbsp;&nbsp;&nbsp;Token&nbsp;token&nbsp;=&nbsp;scanner.getNext();<br />&nbsp;&nbsp;&nbsp;&nbsp;while&nbsp;(token.type&nbsp;!=&nbsp;Eof)&nbsp;{<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;switch&nbsp;(token.type)&nbsp;{<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;case&nbsp;Short:&nbsp;std::cout&nbsp;&lt;&lt;&nbsp;"Keyword:&nbsp;short"&nbsp;&lt;&lt;&nbsp;std::endl;&nbsp;break;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;case&nbsp;Int:&nbsp;std::cout&nbsp;&lt;&lt;&nbsp;"Keyword:&nbsp;int"&nbsp;&lt;&lt;&nbsp;std::endl;&nbsp;break;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;case&nbsp;Assign:&nbsp;std::cout&nbsp;&lt;&lt;&nbsp;"Symbol:&nbsp;\'=\'"&nbsp;&lt;&lt;&nbsp;std::endl;&nbsp;break;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;case&nbsp;SemiColon:&nbsp;std::cout&nbsp;&lt;&lt;&nbsp;"Symbol:&nbsp;\';\'"&nbsp;&lt;&lt;&nbsp;std::endl;&nbsp;break;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;case&nbsp;Id:&nbsp;std::cout&nbsp;&lt;&lt;&nbsp;"Identifier:&nbsp;"&nbsp;&lt;&lt;&nbsp;token.idVal&nbsp;&lt;&lt;&nbsp;std::endl;&nbsp;break;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;case&nbsp;IntL:&nbsp;std::cout&nbsp;&lt;&lt;&nbsp;"Integer&nbsp;Literal:&nbsp;"&nbsp;&lt;&lt;&nbsp;token.intVal&nbsp;&lt;&lt;&nbsp;std::endl;&nbsp;break;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;default:&nbsp;{<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;std::cout&nbsp;&lt;&lt;&nbsp;"Error:&nbsp;Unknown&nbsp;token."&nbsp;&lt;&lt;&nbsp;std::endl;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;token&nbsp;=&nbsp;scanner.getNext();<br />&nbsp;&nbsp;&nbsp;&nbsp;}<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br />&nbsp;&nbsp;&nbsp;&nbsp;std::cout&nbsp;&lt;&lt;&nbsp;"EOF&nbsp;reached."&nbsp;&lt;&lt;&nbsp;std::endl;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br />&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;0;<br />}<br /></code>
<br /><br />
<br /><br /><br /></p>
</div>
    </body>
</html>

