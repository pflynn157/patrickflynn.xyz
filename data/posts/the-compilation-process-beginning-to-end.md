---
title: "The Compilation Process: Beginning to End"
date: "2021-07-18"
categories: 
  - "compilers"
---

In my last post, I briefly mentioned the difference between a compiler and an interpreter. I also mentioned an assembler. Understanding the difference and purpose between those tools are crucial before we can go any further. Therefore, we will look at that today.

### What Exactly is a Compiler?

To a computer scientist, a compiler is a program that takes source code and translates it to assembly.

And that's all.

Consider this C program:

```
int main() {
    puts("Hello, world!");
    int x = 10;
    return x + 8;
}
```

I'm not about explain what that does. However, if you go run it through a C compiler such as GCC, you will end up with this:

```
.LC0:
        .string "Hello, world!"
main:
        push    rbp
        mov     rbp, rsp
        sub     rsp, 16
        mov     edi, OFFSET FLAT:.LC0
        call    puts
        mov     DWORD PTR \[rbp-4\], 10
        mov     eax, DWORD PTR \[rbp-4\]
        add     eax, 8
        leave
        ret
```

That gibberish you ended up with is called assembly code (or assembly language). Assembly language is a human-readable representation of the underlying machine instructions- it tells the computer specifically what to do. A computer can't understand C, C++, or any other language you throw at it. It can only understand its own specific assembly language (we'll save this for another post, but every CPU has its own assembly language. Don't worry about this for right now).

This is what a compiler does. It reads your C source file, builds a representation of it that it can understand, analyzes it, and finally spits out assembly.

However, the CPU still can't understand your generated assembly file. The assembly has to be translated into the underlying numerical instructions that electronic hardware can understand. As a result, we need an assembler.

### The Assembler

An assembler can be thought of as a compiler for assembly language. However, an assembler is not considered the same thing as a compiler in computer science. Compilers do a lot of fancy things to the source code- besides the fact that parsing source code and making sense of it is much more difficult than parsing assembly. Assemblers read the file, and make a direct 1:1 translation to the binary file.

Its also important to understand that while compilers often can generate assembly for multiple architectures (GCC can compile C code for your desktop, your phone, your Raspberry Pi, your Arduino, and many other things), assemblers can only assemble one specific assembly language. That's why this step is kept separate from the compiler. Its both easier and makes more sense for a compiler to generate code, and call an assembler, rather than trying to do everything itself.

### Linking

Assembly is actually not the final step of the compilation process (unless you're making an operating system, but that's another subject for another day). Before you can run your assembled program, you have to link it.

In addition to being in a format that the CPU can understand, the final compiled program also has to be in a format the operating system can understand. To run your program, the OS will load it, load any libraries needed by it, and point the CPU to the section of memory your program was loaded to. While assemblers can generate the OS-specific format, they can't resolve any libraries your program needs. Which is where the linker comes in.

I assume you know what a library is. If not, in a nutshell its a collection of compiled, executable code that many programs can use. However, the operating system has to know which library to load when it loads your program. The linker modifies the file generated by the assembler to contain this information. Once the process is done, you have a finished executable you can run.

### Interpreters

Not every language is compiled, however. Languages like HTML, Javascript, and Python are immediately run when you want them. And Java, as we know, is run by the JVM (Java Virtual Machine). What happens in this case?

This is where interpreters come in. Interpreters are basically programs that can run another program. Interpreters themselves are almost always compiled. After all, an interpreter running an interpreter would be painfully slow.

Other than perhaps HTML, most interpreted languages aren't run directly from source. Doing so, especially if its a program run many times, is time consuming and slow. As a result, many interpreters cache programs into bytecode. Bytecode is a virtual architecture, if you will. It sill requires another interpreter to run it, but parsing a file of numbers is much faster than parsing a string. If you've ever seen Python run, for example, you may have noticed the "__pycache__" folder. This folder contains Python bytecode.

Java and the JVM is a particularly good example for this. The difference, however, is that the bytecode is not internal. You build Java specifically for the JVM, and then take your bytecode with you. Java is considered a separate compiler and virtual machine, but the overall concept is the same to most other interpreters.

Interpreters, even if you go the bytecode path, are generally easier to write then compilers. Because everything runs in userspace- within the operating system's environment- you don't have to worry about the underlying architecture and more difficult concepts such as assembling and linking. Of course, there is a tradeoff. Interpreters, even with bytecode, are always going to be slower than compiled languages.

### The Big Picture

Okay, let's tie all this together.

A compiler reads your source file, analyzes it, and generates an assembly file for your specific computer architecture. An assembler will then translate the assembly file into a binary form that the physical CPU can understand. Finally, a linker will come and make adjustments so your operating system can load and run your program.

If you want to side-step this process, you can write an interpreter, which will load an run your source code right then and there (though perhaps with an intermediate step of translating to bytecode code). This process is slower, but is also easier to make.

Hopefully this makes the concepts surrounding compilers understandable. While I've done work in all the stages of compiling, I tend to stay mainly in the compiler area. For the most part, that's what I'll be focusing on.

Thanks for reading!
